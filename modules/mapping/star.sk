_mapping__aligner = 'star'
include: 'mapping.sk'
include: "star.py"

star__dir           = mapping__aligner_dir
star__sample_prefix = star__dir + "/{sample_name}/{sample_name}"
star__sample_io     = star__sample_prefix + ".bam"

rule star__alignSamples_all:
  input:
    samples_bam = lambda wildcards:
      fastq__mapStringSamples(star__sample_io, **wildcards)
  output: 
    primary = mapping__dir + "/star__alignSamples_all.done"
  run:
    touch(output)

rule star__alignSample:
  input: 
    reads_1 = lambda wildcards: fastq__mapSampleReads("R1", **wildcards),
    reads_2 = lambda wildcards: fastq__mapSampleReads("R2", **wildcards)
  output:
    primary   = star__sample_io,
    raw_file  = star__sample_prefix + ".Aligned.sortedByCoord.out.bam",
    out_files = [ 
      star__sample_prefix + out_file
      for out_file in [ 
        ".Log.out", ".Log.progress.out", ".Log.final.out", ".SJ.out.tab" 
      ]
    ]
  run:
    cmd = """
     condactivate
     {star.command}                                         \ 
       --runThreadN {star.cores}                            \
       --genomeDir {star_genome_index}                      \
       --readFilesIn {reads}                                \
       --outSAMstrandField intronMotif                      \
       --outFileNamePrefix {prefix}.                        \
       --outSAMtype BAM SortedByCoordinate                  \
       --outSAMunmapped Within                              \
       --outFilterMismatchNmax {star.outFilterMismatchNmax} \
       --readFilesCommand zcat                              \
      > {output.primary}
  
     # Test to remove: Understand why we have to link aligned.sortedByCoord.out.bam
     if [ -f {output.raw_file} ]; then
       echo "Found out bam '{output.raw_file}'"
     else
       echo "No out bam found '{output.raw_file}'"
     fi
     ln.rel -f {output.raw_file} {output.primary}
    """.format(
      output = output,
      star   = pipeman.config.pipeline.modules.mapping.star,
      prefix = os.path.dirname(output.primary),
      reads  = star__readsToString(input.reads_1, input.reads_2),
      star_genome_index = star__genomeIndex(),)

    exshell(input, output, cmd, **wildcards)

 
rule star__align_chunk_star:
  input:
      # samples_map = fastq_samples_map,
      #fastq_reads= lambda wildcards: csvmap__formatStrFromQueryDict(
      #          csvmap=fastq_csvmap, 
      #          str_format=fastq__chunk_format + ".fastq.gz",
      #          **wildcards)
    fastq_reads = lambda wildcards: 
      fastq__queryFastqSamples(fastq__chunk_format + ".fastq.gz", **wildcards)
  output: 
    primary = mapping__chunk_format + "{process}.bam",
    bam_file_raw = mapping__chunk_format + "{process}.Aligned.sortedByCoord.out.bam",
    raw_files = [ mapping__chunk_format + "{process}." + _raw for _raw in
       [ "Log.out", "Log.progress.out", "Log.final.out", "SJ.out.tab" ]
    ]
  wildcard_constraints:
     process="(\.star)"
  run:
    star = pipeman.config.pipeline.modules.mapping.star
    cmd = """
     condactivate #> {output[primary]}.out ## DRY_RUN
     STAR \
       --runThreadN {STAR_CORES} \
       --genomeDir {STAR_GENOME_INDEX} \
       --readFilesIn {input[fastq_reads]} \
       --outSAMstrandField intronMotif \
       --outFileNamePrefix {wildcards.sample_run}/{wildcards.sample_name}/{wildcards.sample_name}_{wildcards.sample_number}_{wildcards.sample_lane}_{wildcards.sample_chunknb}{wildcards.preprocesses}{wildcards.process}. \
       --outSAMtype BAM SortedByCoordinate \
       --outSAMunmapped Within \
       --outFilterMismatchNmax {STAR_outFilterMismatchNmax} \
       --readFilesCommand zcat \
      > {output[primary]}.out;  # DRY_RUN
     #touch {output} ## DRY_RUN 
     ln.rel -f {output[bam_file_raw]} {output[primary]}
    """
    exshell(input, output, cmd, **wildcards)
