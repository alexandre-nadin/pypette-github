from utils import csv_helper
from utils.fastq_helper import FastqFile

# -------------------------------
# Wildcards Constraints
#
# Organization of the outputs follows a convention both in the naming of the 
# files as in their directories. As such, we define regex constraints on the rules' 
# wildcards. Those wildcards are defined outside of the rules, so they are 
# global to all the rules. Each constraint can then be overridden specifically 
# in the rule itself, the last declaration prevailing.
# -------------------------------------------------------------------
wildcard_constraints:
  sample_name    = FastqFile.regex_fields.sample_name,
  sample_number  = FastqFile.regex_fields.sample_number,
  sample_lane    = FastqFile.regex_fields.sample_lane,
  sample_chunknb = FastqFile.regex_fields.sample_chunknb,
  sample_read    = FastqFile.regex_fields.sample_read,
  preprocesses   = "(\.\w+)*?"

# --------------------- 
# I/O files format
#
# Convention: 
#   - {preprocesses} should be present both in the input and output. Can be empty.
#   - {process} is only for outputs as it is about the process defined by the
#     current rule.
# --------------------- 
fastq__chunk_format="{sample_run}/{sample_name}/{sample_chunkname}{preprocesses}"

# ---------------------
# Mapping fastq files
# ---------------------
# We first need to define our csv mapper by specifying the column names:
fastq__csvmap = csv_helper.CsvMap('fastq_samples.map', delimitor='\t', colnames=FastqFile.get_field_names()) 
fastq__map_sep = "\t"
fastq__samples_map = "fastq_samples.map"

rule fastq__fastq_files:
  #
  # Find all the fastq files in the RUN dirctories found in configuration.
  #
  output: 
      primary= "{prj_name}/fastq/fastq_files.txt"
  shell:"""
    find {RAW_DATA_DIRS} -name '*.fastq.gz' > {output}
  """ 

def get_run_from_filepath(filename):
  #
  # Retrieve a Run id from a file containing paths.
  #
  for _run in RUN_IDS:
      run_path = os.sep.join([RUN_BASEDIR, _run, ''])
      if filename.startswith(run_path):
          return _run
      else:
         continue

rule fastq__fastq_samples:
  #   
  # Maps all the illumina filename metadata in a file.
  #   
  input: 
      file="fastq_files.txt"
  output: 
      primary="fastq_samples.map"
  run:
      with open(input['file'], 'r') as files:
          for _file in files:
              ## Deduce file's run name
              sample_run = get_run_from_filepath(_file)

              ## Get file's info
              fastqfile = FastqFile(_file.strip(), run_name=sample_run)

              ## Write to output
              with open(output['primary'], 'a') as fmap:
                  fmap.write("{}{}".format(fastq__map_sep.join(
                    [fastqfile.__dict__[_field] \
                      for _field in list(FastqFile.get_field_names())
                    ]   
                   ), os.linesep))


# -----------------
# Link fastq reads
# -----------------
localrules: fastq__link_fastq_read
rule fastq__link_fastq_read:
  #
  # Links original fastq file to the project directory.
  #
  input:
      #samples_map = fastq__samples_map,
      fastq_read= lambda wildcards: csvmap__format_str_from_query_dict(
                csvmap=fastq__csvmap, 
                str_format="{sample_path}",
                **wildcards)
  output: 
      primary=fastq__chunk_format + ".fastq.gz"
  shell:"""
    ln.rel {input[fastq_read]} {output[primary]} 
  """

# ---------------
# Fastq Quality
# ---------------
FASTQC_CORES = 6
rule fastq__fastqc_file:
  input:
      fastq_in= "{prefix}.fastq.gz"
  output:
      primary= "{prefix}.fastqc.html"
  shell:"""
    fastqc -o $(dirname {input[fastq_in]}) -t {FASTQC_CORES} {input[fastq_in]}
  """ 
