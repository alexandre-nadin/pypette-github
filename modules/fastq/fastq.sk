from utils.fastq_helper import FastqFile
from utils.files import touch
pipeman.includeModule('lims/lims.sk')
include: "fastq.py"

# -------------------------------
# Wildcards Constraints
#
# Organization of the outputs follows a convention both in the naming of the 
# files as in their directories. As such, we define regex constraints on the rules' 
# wildcards. Those wildcards are defined outside of the rules, so they are 
# global to all the rules. Each constraint can then be overridden specifically 
# in the rule itself, the last declaration prevailing.
# -------------------------------------------------------------------
pipeman.updateWildcardConstraints(
  **FastqFile.regex_fields,
  preprocesses = "(\.\w+)*?",
  extension    = "\.\w+",
)
    
# --------------------- 
# I/O files format
#
# Convention: 
#   - {preprocesses} should be present both in the input and output. Can be empty.
#   - {process} is only for outputs as it is about the process defined by the
#     current rule.
# --------------------- 
fastq__raw_files_io = "{project}/fastq/raw_files.txt"
fastq__dir = "{project}/fastq"
fastq__mapped_samples_io     = fastq__dir + "/samples{extension}"
fastq__mapped_samples_io_dft = fastq__dir + "/samples.csv"
fastq__chunk_io = fastq__dir + "/{sample_run}/{sample_name}/{sample_chunkname}{sample_extension}"
fastq__merged_io = fastq__dir + "/{sample_run}/{sample_name}/{sample_name}_{sample_number}_{sample_read}_{sample_chunknb}_{sample_extension}"
fastq__sample_read_prefix = fastq__dir + "/{sample_name}/{sample_name}_{sample_read}"
fastq__sample_read_io = fastq__sample_read_prefix + ".fastq.gz"
fastq__sample_read_fastqc_io = fastq__sample_read_prefix + ".fastqc{extension}"

# ---------------
# Merging Reads
# ---------------
rule fastq__mergeSampleReads_all:
  """
  Merges all sample reads filtered by the given wildcards.
  """
  input:
    reads_1 = lambda wildcards: fastq__mapSampleReads("R1", **wildcards),
    reads_2 = lambda wildcards: fastq__mapSampleReads("R2", **wildcards)
  output:
    primary = fastq__dir + "/fastq__mergeSampleReads_all.done"
  run:
    touch(output)

rule fastq__mergeSampleReads:
  """
  Merges sample reads filtered by the given wildcards.
  """
  input:
    reads = lambda wildcards:
      fastq__mapStringSamples(fastq__chunk_io, **wildcards)
  output:
    primary = fastq__sample_read_io
  run:
    cmd = """
    zcat {input.reads} \
     | gzip              \
     > {output.primary}
    """.format(input=input, output=output)
    exshell(input, output, cmd, **wildcards)

# ---------------------
# Mapping fastq files
# ---------------------
rule fastq__mapRawFiles:
  """
  Find all the fastq files in the RUN directories specified in the 
  configuration.
  """
  input:
    metadata = lims__project_metadata_io
  output: 
    primary  = fastq__raw_files_io
  run:
    lims__setConfigs(**wildcards)
    runs = fastq__runsPathsProject(wildcards.project)
    shell("""
      find {runs} -name '*.fastq.gz' > {output}
    """)

rule fastq__mapSamples:
  """   
  Maps all the illumina filenames' metadata in a file.
  """
  input: 
    file    = fastq__raw_files_io
  output: 
    primary = fastq__mapped_samples_io
  run:
    lims__setConfigs(**wildcards)

    """ File Output Header """
    sample_lines = [ FastqFile.fieldNames() ]
    with open(input.file, 'r') as fastq_files:
      """ Mapped Samples Lines """
      sample_lines.extend(list(map(fastq__mapFilename, fastq_files)))

    """ Write Output """
    with open(output.primary, 'a') as fmap:
      fmap.write(
        pipeman.samples.listsToSamplesheet(
          sample_lines, 
          pipeman.sampleExtensions[wildcards.extension]))

# -----------------
# Link fastq reads
# -----------------
rule fastq__linkRead:
  """
  Links original fastq file to the project directory.
  """
  input:
    fastq_read = lambda wildcards:
      fastq__mapStringSamples("{sample_path}", **wildcards)
  output: 
    primary    = fastq__chunk_io
  shell:"""
    ln.rel {input.fastq_read} {output.primary} 
  """

rule fastq__linkReads:
  input: 
    fastq_files = lambda wildcards: 
      fastq__mapStringSamples(fastq__chunk_io, **wildcards)
  output: fastq__dir + "/fastq__linkReads.done"
  run:
    touch(output)

localrules: fastq__linkRead, fastq__linkReads

# --------------
# Fastq Quality
# --------------
rule fastq__fastqcSampleReads_all:
  """
  Produces a Fastqc report for all samples' merged fastq reads.
  """
  input:
    lambda wildcards: 
      fastq__mapStringSamples(fastq__sample_read_fastqc_io + ".html", **wildcards)
  output:
    primary = fastq__dir + "/fastq__fastqcSampleReads_all.done"
  run:
    touch(output) 

rule fastq__fastqcSampleRead:
  """
  Produces a Fastqc report for a sample's merged fastq reads.
  """
  input: lambda x: rules.fastq__mergeSampleReads.output.primary
  output:
    primary = fastq__sample_read_prefix + ".fastqc.html",
    zip = fastq__sample_read_prefix + ".fastqc.zip"
  run:
    lims__setConfigs(**wildcards)
    cmd = """
      fastqc -t {fastqc.cores} {input}
    """.format(
          input=input, 
          fastqc=pipeman.config.pipeline.rnaseq.modules.fastqc)
    exshell(input, output, cmd, **wildcards)
   
# ---------
# Cleaning
# ---------
pipeman.toClean("fastq__*.done")
