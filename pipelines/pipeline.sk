#!/usr/bin/env python
import utils.pipeline

explain_rules_fields = ['name', 'wildcard_names', '_wildcard_constraints', 'snakefile']
rule explain_rules:
  """
  Lists all available rules (snakemake -l) but also gives more
  information such as the file in which the rule is found.
  """
  run:
    print('\t|\t'.join([_rule_field.upper() 
                       for _rule_field in explain_rules_fields
                    ]))
    for _rule in rules.__dict__.keys():
      print('\t|\t'.join([str(rules.__dict__[_rule].__dict__[_rule_field]) 
                              for _rule_field in explain_rules_fields
                        ]))

rule samplenames:
  """
  List all sample names.
  """
  run:
    print(pipeman.samples.data['sample_name'])

rule samples:
  """
  List all samples.
  """
  run:
    print(pipeman.samples.data)

onsuccess:
  if 'pipeline_manager' in globals().keys() \
  and pipeman.cleanables:
    pipeman.log.info(
      "Success! Now removing cleanable files {}..."
       .format(pipeman.cleanables))
    shell("rm -f {}".format(" ".join(pipeman.cleanables)))

# -----------------
# PipelineManager
# -----------------
def newPipelineManager(name):
  """
  Declares a new PipelineManager the easiest way.
  Purpose: who writes a piepeline doesn't have to care about the global namespace.
  Default namespace: globals()
  """
  return utils.pipeline.PipelineManager(name=name, namespace=globals())
